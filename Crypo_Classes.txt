#include "ara/crypto/cryp/auth_cipher_ctx.h"
namespace ara::crypto::cryp
class AuthCipherCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<AuthCipherCtx>;

	
	virtual ara::core::Result<bool> Check (const Signature &expected)
const noexcept=0;


	virtual DigestService::Uptr GetDigestService () const noexcept=0;
	
	
	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > GetDigest (std::size_t offset=0)
const noexcept;

	virtual ara::core::Result<CryptoTransform> GetTransformation () const
noexcept=0;


	virtual std::uint64_t GetMaxAssociatedDataSize () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
ConfidentialData (ReadOnlyMemRegion in, ara::core::Optional< ReadOnly
MemRegion > expectedTag) noexcept=0;

	virtual ara::core::Result<void> ProcessConfidentialData (ReadWriteMem
Region inOut, ara::core::Optional< ReadOnlyMemRegion > expectedTag)
noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const SymmetricKey &key,
CryptoTransform transform=CryptoTransform::kEncrypt) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnly
MemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv)
noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (const Restricted
UseObject &in) noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (ReadOnlyMem
Region in) noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (std::uint8_t in)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/block_service.h"
namespace ara::crypto::cryp
class BlockService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<BlockService>;
	
	virtual std::size_t GetActualIvBitLength (ara::core::Optional< Crypto
ObjectUid > ivUid) const noexcept=0;

	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetIvSize () const noexcept=0;
	
	virtual bool IsValidIvSize (std::size_t ivSize) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_context.h"
namespace ara::crypto::cryp
class CryptoContext 
{
public:
	using AlgId = CryptoAlgId;
	
	virtual ~CryptoContext () noexcept=default;
	
	virtual CryptoPrimitiveId::Uptr GetCryptoPrimitiveId () const
noexcept=0;

	virtual bool IsInitialized () const noexcept=0;
	
	CryptoContext& operator= (const CryptoContext &other)=default;

	CryptoContext& operator= (CryptoContext &&other)=default;

	virtual CryptoProvider& MyProvider () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/crypto_object.h
namespace ara::crypto::cryp
class CryptoObject 
{
public:
	struct COIdentifier 
	{
	   CryptoObjectType mCOType;
	   CryptoObjectUid mCouid;
	};
	using Uptrc = std::unique_ptr<const CryptoObject>;
	using Uptr = std::unique_ptr<CryptoObject>
	
	virtual ~CryptoObject () noexcept=default;
	
	template <class ConcreteObject>
static ara::core::Result<typename ConcreteObject::Uptrc> Downcast (
CryptoObject::Uptrc &&object) noexcept;

	virtual CryptoPrimitiveId::Uptr GetCryptoPrimitiveId () const
noexcept=0;

	virtual COIdentifier GetObjectId () const noexcept=0;
	
	virtual std::size_t GetPayloadSize () const noexcept=0;
	
	virtual COIdentifier HasDependence () const noexcept=0;
	
	virtual bool IsExportable () const noexcept=0;
	
	virtual bool IsSession () const noexcept=0;
	
	virtual ara::core::Result<void> Save (IOInterface &container) const
noexcept=0;

	CryptoObject& operator= (const CryptoObject &other)=default;

	CryptoObject& operator= (CryptoObject &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/crypto_primitive_id.h
namespace ara::crypto::cryp
class CryptoPrimitiveId 
{
public:
	using AlgId = CryptoAlgId;
	using Uptrc = std::unique_ptr<const CryptoPrimitiveId>;
	using Uptr = std::unique_ptr<CryptoPrimitiveId>;
	
	virtual ~CryptoPrimitiveId () noexcept=default;
	
	virtual AlgId GetPrimitiveId () const noexcept=0;
	
	virtual const ara::core::StringView GetPrimitiveName () const
noexcept=0;

	CryptoPrimitiveId& operator= (const CryptoPrimitiveId &other)=default;

	CryptoPrimitiveId& operator= (CryptoPrimitiveId &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_provider.h"
namespace ara::crypto::cryp
class CryptoProvider 
{
public:
	using AlgId = CryptoPrimitiveId::AlgId;
	using Uptr = std::unique_ptr<CryptoProvider>;
	
	virtual ara::core::Result<VolatileTrustedContainer::Uptr> Alloc
VolatileContainer (std::size_t capacity=0) noexcept=0;

	virtual ara::core::Result<VolatileTrustedContainer::Uptr> Alloc
VolatileContainer (std::pair< AlgId, CryptoObjectType > theObjectDef)
noexcept=0;

	virtual AlgId ConvertToAlgId (ara::core::StringView primitiveName)
const noexcept=0;

	virtual ara::core::Result<ara::core::String> ConvertToAlgName (AlgId
algId) const noexcept=0;

	virtual ara::core::Result<AuthCipherCtx::Uptr> CreateAuthCipherCtx (
AlgId algId) noexcept=0;
	
	virtual ara::core::Result<DecryptorPrivateCtx::Uptr> CreateDecryptor
PrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<EncryptorPublicCtx::Uptr> CreateEncryptor
PublicCtx (AlgId algId) noexcept=0;


	virtual ara::core::Result<Signature::Uptrc> CreateHashDigest (AlgId
hashAlgId, ReadOnlyMemRegion value) noexcept=0;

	virtual ara::core::Result<HashFunctionCtx::Uptr> CreateHashFunctionCtx
(AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyAgreementPrivateCtx::Uptr> CreateKey
AgreementPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyDecapsulatorPrivateCtx::Uptr> CreateKey
DecapsulatorPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyDerivationFunctionCtx::Uptr> CreateKey
DerivationFunctionCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyEncapsulatorPublicCtx::Uptr> CreateKey
EncapsulatorPublicCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<MessageAuthnCodeCtx::Uptr> CreateMessageAuth
CodeCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<MsgRecoveryPublicCtx::Uptr> CreateMsg
RecoveryPublicCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<RandomGeneratorCtx::Uptr> CreateRandom
GeneratorCtx (AlgId algId=kAlgIdDefault, bool initialize=true)
noexcept=0;

	virtual ara::core::Result<SigEncodePrivateCtx::Uptr> CreateSigEncode
PrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> CreateSignature (AlgId
signAlgId, ReadOnlyMemRegion value, const RestrictedUseObject &key,
AlgId hashAlgId=kAlgIdNone) noexcept=0;

	virtual ara::core::Result<SignerPrivateCtx::Uptr> CreateSignerPrivate
Ctx (AlgId algId) noexcept=0;

	virtual ara::core::Result<StreamCipherCtx::Uptr> CreateStreamCipherCtx
(AlgId algId) noexcept=0;

	virtual ara::core::Result<SymmetricBlockCipherCtx::Uptr> Create
SymmetricBlockCipherCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<SymmetricKeyWrapperCtx::Uptr> Create
SymmetricKeyWrapperCtx (AlgId algId) noexcept=0;
	
	virtual ara::core::Result<VerifierPublicCtx::Uptr> CreateVerifier
PublicCtx (AlgId algId) noexcept=0;

	virtual ~CryptoProvider () noexcept=default;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Export
PublicObject (const IOInterface &container, Serializable::FormatId
formatId=Serializable::kFormatDefault) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Export
SecuredObject (const CryptoObject &object, SymmetricKeyWrapperCtx
&transportContext) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Export
SecuredObject (const IOInterface &container, SymmetricKeyWrapperCtx
&transportContext) noexcept=0;

	virtual ara::core::Result<PrivateKey::Uptrc> GeneratePrivateKey (AlgId
algId, AllowedUsageFlags allowedUsage, bool isSession=false, bool is
Exportable=false) noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> GenerateSeed (AlgId alg
Id, SecretSeed::Usage allowedUsage, bool isSession=true, bool is
Exportable=false) noexcept=0;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> GenerateSymmetricKey (
AlgId algId, AllowedUsageFlags allowedUsage, bool isSession=true, bool
isExportable=false) noexcept=0;

	virtual ara::core::Result<std::size_t> GetPayloadStorageSize (Crypto
ObjectType cryptoObjectType, AlgId algId) const noexcept=0;

	virtual ara::core::Result<std::size_t> GetSerializedSize (CryptoObject
Type cryptoObjectType, AlgId algId, Serializable::FormatId format
Id=Serializable::kFormatDefault) const noexcept=0;

	virtual ara::core::Result<void> ImportPublicObject (IOInterface
&container, ReadOnlyMemRegion serialized, CryptoObjectType expected
Object=CryptoObjectType::kUndefined) noexcept=0;

	virtual ara::core::Result<void> ImportSecuredObject (IOInterface
&container, ReadOnlyMemRegion serialized, SymmetricKeyWrapperCtx
&transportContext, bool isExportable=false, CryptoObjectType expected
Object=CryptoObjectType::kUndefined) noexcept=0;

	virtual ara::core::Result<CryptoObject::Uptrc> LoadObject (const
IOInterface &container) noexcept=0;

	virtual ara::core::Result<PrivateKey::Uptrc> LoadPrivateKey (const
IOInterface &container) noexcept=0;

	virtual ara::core::Result<PublicKey::Uptrc> LoadPublicKey (const
IOInterface &container) noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> LoadSecretSeed (const
IOInterface &container) noexcept=0;

	virtual ara::core::Result<SymmetricKey::Uptrc> LoadSymmetricKey (const
IOInterface &container) noexcept=0;

	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const
noexcept=0;

	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false)
const noexcept=0;

	CryptoProvider& operator= (const CryptoProvider &other)=default;
	
	CryptoProvider& operator= (CryptoProvider &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_service.h"
namespace ara::crypto::cryp
class CryptoService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<CryptoService>;
	
	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const
noexcept=0;
	
	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false)
const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/decryptor_private_ctx.h"
namespace ara::crypto::cryp
class DecryptorPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<DecryptorPrivateCtx>;
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Block (ReadOnlyMemRegion in, bool suppressPadding=false) const
noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > ProcessBlock (ReadOnlyMemRegion
in, bool suppressPadding=false) const noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/digest_service.h"
namespace ara::crypto::cryp
class DigestService : public BlockService 
{
public:
	using Uptr = std::unique_ptr<DigestService>;
	
	virtual ara::core::Result<bool> Compare (ReadOnlyMemRegion expected,
std::size_t offset=0) const noexcept=0;

	virtual std::size_t GetDigestSize () const noexcept=0;
	
	virtual bool IsFinished () const noexcept=0;
	
	virtual bool IsStarted () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/encryptor_public_ctx.h
namespace ara::crypto::cryp
class EncryptorPublicCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<EncryptorPublicCtx>;
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Block (ReadOnlyMemRegion in, bool suppressPadding=false) const
noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > ProcessBlock (ReadOnlyMemRegion
in, bool suppressPadding=false) const noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/extension_service.h"
namespace ara::crypto::cryp
class ExtensionService 
{
public:
	using Uptr = std::unique_ptr<ExtensionService>;
	
	virtual ~ExtensionService () noexcept=default;
	
	virtual std::size_t GetActualKeyBitLength () const noexcept=0;

	virtual CryptoObjectUid GetActualKeyCOUID () const noexcept=0;

	virtual AllowedUsageFlags GetAllowedUsage () const noexcept=0;
	
	virtual std::size_t GetMaxKeyBitLength () const noexcept=0;

	virtual std::size_t GetMinKeyBitLength () const noexcept=0;

	virtual bool IsKeyBitLengthSupported (std::size_t keyBitLength) const
noexcept=0;

	virtual bool IsKeyAvailable () const noexcept=0;
	
	ExtensionService& operator= (const ExtensionService &other)=default;

	ExtensionService& operator= (ExtensionService &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/hash_function_ctx.h"
namespace ara::crypto::cryp
class HashFunctionCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<HashFunctionCtx>;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Finish
() noexcept=0;

	virtual DigestService::Uptr GetDigestService () const noexcept=0;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Get
Digest (std::size_t offset=0) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > GetDigest (std::size_t offset=0)
const noexcept;

	virtual ara::core::Result<void> Start () noexcept=0;
	
	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv)
noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv)
noexcept=0;

	virtual ara::core::Result<void> Update (const RestrictedUseObject &in)
noexcept=0;

	virtual ara::core::Result<void> Update (ReadOnlyMemRegion in)
noexcept=0;

	virtual ara::core::Result<void> Update (std::uint8_t in) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_agreement_private_ctx.h"
namespace ara::crypto::cryp
class KeyAgreementPrivateCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyAgreementPrivateCtx>;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> AgreeKey (const Public
Key &otherSideKey, CryptoAlgId targetAlgId, AllowedUsageFlags allowed
Usage, ara::core::Optional< const KeyDerivationFunctionCtx::Uptr >
kdf, ara::core::Optional< ReadOnlyMemRegion > salt,
ara::core::Optional< ReadOnlyMemRegion > ctxLabel) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> AgreeSeed (const Public
Key &otherSideKey, ara::core::Optional< AllowedUsageFlags > allowed
Usage) const noexcept=0;

	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_decapsulator_private_ctx.h"
namespace ara::crypto::cryp
class KeyDecapsulatorPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<KeyDecapsulatorPrivateCtx>;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> DecapsulateKey (Read
OnlyMemRegion input, CryptoAlgId keyingDataAlgId, KeyDerivation
FunctionCtx &kdf, CryptoAlgId kekAlgId, ara::core::Optional< Allowed
UsageFlags > allowedUsage) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> DecapsulateSeed (ReadOnly
MemRegion input, ara::core::Optional< AllowedUsageFlags > allowed
Usage) const noexcept=0;

	virtual std::size_t GetEncapsulatedSize () const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetKekEntropy () const noexcept=0;
	
	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_derivation_function_ctx.h"
namespace ara::crypto::cryp
class KeyDerivationFunctionCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyDerivationFunctionCtx>;
	
	virtual ara::core::Result<void> AddSalt (ReadOnlyMemRegion salt)
noexcept=0;

	virtual ara::core::Result<void> AddSecretSalt (const SecretSeed &salt)
noexcept=0;

	virtual std::uint32_t ConfigIterations (std::uint32_t iterations=0)
noexcept=0;

	virtual ara::core::Result<SymmetricKey::Uptrc> DeriveKey (bool is
Session=true, bool isExportable=false) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> DeriveSeed (bool is
Session=true, bool isExportable=false) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetKeyIdSize () const noexcept=0;

	virtual AlgId GetTargetAlgId () const noexcept=0;
	
	virtual AllowedUsageFlags GetTargetAllowedUsage () const noexcept=0;

	virtual std::size_t GetTargetKeyBitLength () const noexcept=0;

	virtual ara::core::Result<void> Init (ReadOnlyMemRegion targetKeyId,
AlgId targetAlgId=kAlgIdAny, AllowedUsageFlags allowedUsage=kAllowKdf
MaterialAnyUsage, ReadOnlyMemRegion ctxLabel=ReadOnlyMemRegion())
noexcept=0;
	
	virtual ara::core::Result<void> SetSourceKeyMaterial (const Restricted
UseObject &sourceKM) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_encapsulator_public_ctx.h
namespace ara::crypto::cryp
class KeyEncapsulatorPublicCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyEncapsulatorPublicCtx>;
	
	virtual std::size_t GetEncapsulatedSize () const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetKekEntropy () const noexcept=0;
	
	virtual ara::core::Result<void> AddKeyingData (const RestrictedUse
Object &keyingData) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> >
Encapsulate (KeyDerivationFunctionCtx &kdf, CryptoAlgId kekAlgId)
const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key)
noexcept=0;

}
---------------------------------------------------
#include "ara/crypto/cryp/message_authn_code_ctx.h"
namespace ara::crypto::cryp
class MessageAuthnCodeCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<MessageAuthnCodeCtx>;
	
	virtual ara::core::Result<bool> Check (const Signature &expected)
const noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> Finish (bool makeSignature
Object=false) noexcept=0;

	virtual DigestService::Uptr GetDigestService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Get
Digest (std::size_t offset=0) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > GetDigest (std::size_t offset=0)
const noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const SymmetricKey &key,
CryptoTransform transform=CryptoTransform::kMacGenerate) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnly
MemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv)
noexcept=0;

	virtual ara::core::Result<void> Update (const RestrictedUseObject &in)
noexcept=0;

	virtual ara::core::Result<void> Update (ReadOnlyMemRegion in)
noexcept=0;

	virtual ara::core::Result<void> Update (std::uint8_t in) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/msg_recovery_public_ctx.h
namespace ara::crypto::cryp
class MsgRecoveryPublicCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<MsgRecoveryPublicCtx>;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const
noexcept=0;
	
	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false)
const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Decode
AndVerify (ReadOnlyMemRegion in) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > DecodeAndVerify (ReadOnlyMem
Region in) const noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;

	virtual ara::core::Result<void> SetKey (const PublicKey &key)
noexcept=0;

};

---------------------------------------------------
#include "ara/crypto/cryp/cryobj/private_key.h"
namespace ara::crypto::cryp
class PrivateKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const PrivateKey>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kPrivate
Key;
	
	virtual ara::core::Result<PublicKey::Uptrc> GetPublicKey () const
noexcept=0;

};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/public_key.h"
namespace ara::crypto::cryp
class PublicKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const PublicKey>;

	static const CryptoObjectType kObjectType = CryptoObjectType::kPublic
	Key;
	
	virtual bool CheckKey (bool strongCheck=true) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Hash
PublicKey (HashFunctionCtx &hashFunc) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > HashPublicKey (HashFunctionCtx
&hashFunc) const noexcept;
};
---------------------------------------------------
#include "ara/crypto/cryp/random_generator_ctx.h"
namespace ara::crypto::cryp
class RandomGeneratorCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<RandomGeneratorCtx>;
	
	virtual bool AddEntropy (ReadOnlyMemRegion entropy) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> >
Generate (std::uint32_t count) noexcept=0;

	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual bool Seed (ReadOnlyMemRegion seed) noexcept=0;
	
	virtual bool Seed (const SecretSeed &seed) noexcept=0;
	
	virtual bool SetKey (const SymmetricKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/restricted_use_object.h"
namespace ara::crypto::cryp
class RestrictedUseObject : public CryptoObject {
{
public:
	using Uptrc = std::unique_ptr<const RestrictedUseObject>;
	using Usage = AllowedUsageFlags;
	
	virtual Usage GetAllowedUsage () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/secret_seed.h"
namespace ara::crypto::cryp
class SecretSeed : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const SecretSeed>;
	using Uptr = std::unique_ptr<SecretSeed>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kSecret
Seed;


	virtual ara::core::Result<SecretSeed::Uptr> Clone (ReadOnlyMemRegion
xorDelta=ReadOnlyMemRegion()) const noexcept=0;

	virtual ara::core::Result<void> JumpFrom (const SecretSeed &from,
std::int64_t steps) noexcept=0;

	virtual SecretSeed& Jump (std::int64_t steps) noexcept=0;
	
	virtual SecretSeed& Next () noexcept=0;
	
	virtual SecretSeed& operatorˆ= (const SecretSeed &source) noexcept=0;

	virtual SecretSeed& operatorˆ= (ReadOnlyMemRegion source) noexcept=0;

};
---------------------------------------------------
#include "ara/crypto/cryp/sig_encode_private_ctx.h"
namespace ara::crypto::cryp
class SigEncodePrivateCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<SigEncodePrivateCtx>;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const
noexcept=0;

	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false)
const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > SignAnd
Encode (ReadOnlyMemRegion in) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > SignAndEncode (ReadOnlyMemRegion
in) const noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/signature_service.h"
namespace ara::crypto::cryp
class SignatureService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<SignatureService>;
	
	virtual CryptoPrimitiveId::AlgId GetRequiredHashAlgId () const
noexcept=0;

	virtual std::size_t GetRequiredHashSize () const noexcept=0;

	virtual std::size_t GetSignatureSize () const noexcept=0;

};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/signature.h"
namespace ara::crypto::cryp
class Signature : public CryptoObject
{
public:
	using Uptrc = std::unique_ptr<const Signature>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::k
Signature;

	virtual CryptoPrimitiveId::AlgId GetHashAlgId () const noexcept=0;
	
	virtual std::size_t GetRequiredHashSize () const noexcept=0;
};
---------------------------------------------------

#include "ara/crypto/cryp/signer_private_ctx.h"
namespace ara::crypto::cryp
class SignerPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<SignerPrivateCtx>;
	
	virtual SignatureService::Uptr GetSignatureService () const
noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key)
noexcept=0;
	
	virtual ara::core::Result<Signature::Uptrc> SignPreHashed (const Hash
FunctionCtx &hashFn, ReadOnlyMemRegion context=ReadOnlyMemRegion())
const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Sign
(ReadOnlyMemRegion value, ReadOnlyMemRegion context=ReadOnlyMem
Region()) const noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> SignPreHashed (AlgId hash
AlgId, ReadOnlyMemRegion hashValue, ReadOnlyMemRegion context=ReadOnly
MemRegion()) const noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > Sign (ReadOnlyMemRegion value,
ReadOnlyMemRegion context=ReadOnlyMemRegion()) const noexcept;
};
---------------------------------------------------
#include "ara/crypto/cryp/stream_cipher_ctx.h
namespace ara::crypto::cryp
class StreamCipherCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<StreamCipherCtx>;
	
	virtual std::size_t CountBytesInCache () const noexcept=0;
	
	std::size_t EstimateMaxInputSize (std::size_t outputCapacity) const
noexcept;

	std::size_t EstimateRequiredCapacity (std::size_t inputSize, bool is
Final=false) const noexcept;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Finish
Bytes (ReadOnlyMemRegion in) noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > FinishBytes (ReadOnlyMemRegion
in) noexcept;

	virtual BlockService::Uptr GetBlockService () const noexcept=0;

	virtual bool IsBytewiseMode () const noexcept=0;
	
	virtual ara::core::Result<CryptoTransform> GetTransformation () const
noexcept=0;
	
	virtual bool IsSeekableMode () const noexcept=0;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Blocks (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> ProcessBlocks (ReadWriteMemRegion in
Out) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Bytes (ReadOnlyMemRegion in) noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > ProcessBytes (ReadOnlyMemRegion
in) noexcept;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> Seek (std::int64_t offset, bool from
Begin=true) noexcept=0;

	virtual ara::core::Result<void> SetKey (const SymmetricKey &key,
CryptoTransform transform=CryptoTransform::kEncrypt) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnly
MemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv)
noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/symmetric_block_cipher_ctx.h
namespace ara::crypto::cryp
class SymmetricBlockCipherCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<SymmetricBlockCipherCtx>;
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;
	
	virtual ara::core::Result<CryptoTransform> GetTransformation () const
noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Block (ReadOnlyMemRegion in, bool suppressPadding=false) const
noexcept=0;

	template <typename Alloc = <implementation-defined>>
ara::core::Result<ByteVector<Alloc> > ProcessBlock (ReadOnlyMemRegion
in, bool suppressPadding=false) const noexcept;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Process
Blocks (ReadOnlyMemRegion in) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const SymmetricKey &key,
CryptoTransform transform=CryptoTransform::kEncrypt) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/symmetric_key.h"
namespace ara::crypto::cryp
class SymmetricKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const SymmetricKey>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::k
SymmetricKey;
	
};
---------------------------------------------------

#include "ara/crypto/cryp/symmetric_key_wrapper_ctx.h"
namespace ara::crypto::cryp
class SymmetricKeyWrapperCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<SymmetricKeyWrapperCtx>;
	
	virtual std::size_t CalculateWrappedKeySize (std::size_t keyLength)
const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const
noexcept=0;

	virtual std::size_t GetMaxTargetKeyLength () const noexcept=0;
	
	virtual std::size_t GetTargetKeyGranularity () const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const SymmetricKey &key,
CryptoTransform transform) noexcept=0;

	template <typename ExpectedKey>
ara::core::Result<typename ExpectedKey::Uptrc> UnwrapConcreteKey (Read
OnlyMemRegion wrappedKey, AlgId algId, AllowedUsageFlags allowedUsage)
noexcept;

	virtual ara::core::Result<RestrictedUseObject::Uptrc> UnwrapKey (Read
OnlyMemRegion wrappedKey, AlgId algId, AllowedUsageFlags allowedUsage)
const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> UnwrapSeed (ReadOnlyMem
Region wrappedSeed, AlgId targetAlgId, SecretSeed::Usage allowedUsage)
const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > WrapKey
Material (const RestrictedUseObject &key) const noexcept=0;

};
---------------------------------------------------
#include "ara/crypto/cryp/verifier_public_ctx.h"
namespace ara::crypto::cryp
class VerifierPublicCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<VerifierPublicCtx>;
	
	virtual SignatureService::Uptr GetSignatureService () const
noexcept=0;
	
	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key)
noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed (CryptoAlgId hashAlg
Id, ReadOnlyMemRegion hashValue, const Signature &signature, ReadOnly
MemRegion context=ReadOnlyMemRegion()) const noexcept=0;

	virtual ara::core::Result<bool> Verify (ReadOnlyMemRegion value, Read
OnlyMemRegion signature, ReadOnlyMemRegion context=ReadOnlyMem
Region()) const noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed (const HashFunctionCtx
&hashFn, const Signature &signature, ReadOnlyMemRegion context=Read
OnlyMemRegion()) const noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed (const HashFunctionCtx
&hashFn, ReadOnlyMemRegion signature, ReadOnlyMemRegion context=Read
OnlyMemRegion()) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/common/crypto_object_uid.h"
namespace ara::crypto
struct CryptoObjectUid
{
	Uuid mGeneratorUid;
}
struct CryptoObjectUid {...};
---------------------------------------------------
#include "ara/crypto/keys/keyslot.h"
namespace ara::crypto::keys
class KeySlot
{
public:
	virtual ara::core::Result<void> Clear () noexcept=0;
	
	virtual ~KeySlot () noexcept=default;
	
	virtual ara::core::Result<KeySlotContentProps> GetContentProps ()
const noexcept=0;

	virtual ara::core::Result<cryp::CryptoProvider::Uptr> MyProvider ()
const noexcept=0;

	virtual ara::core::Result<KeySlotPrototypeProps> GetPrototypedProps ()
const noexcept=0;

	virtual bool IsEmpty () const noexcept=0;
	
	virtual ara::core::Result<IOInterface::Uptr> Open (bool subscribeFor
Updates=false, bool writeable=false) const noexcept=0;

	virtual ara::core::Result<void> SaveCopy (const IOInterface
&container) noexcept=0;

	KeySlot& operator= (const KeySlot &other)=default;
	
	KeySlot& operator= (KeySlot &&other)=default;
	
	using Uptr = std::unique_ptr<KeySlot>;
};
---------------------------------------------------
#include "ara/crypto/keys/key_storage_provider.h"
namespace ara::crypto::keys
class KeyStorageProvider
{
public:
	using Uptr = std::unique_ptr<KeyStorageProvider>;

	virtual ara::core::Result<TransactionId> BeginTransaction (const
TransactionScope &targetSlots) noexcept=0;

	virtual ara::core::Result<void> CommitTransaction (TransactionId id)
noexcept=0;

	virtual ~KeyStorageProvider () noexcept=default;
	
	virtual UpdatesObserver::Uptr GetRegisteredObserver () const
noexcept=0;

	virtual ara::core::Result<KeySlot::Uptr> LoadKeySlot (
ara::core::InstanceSpecifier &iSpecify) noexcept=0;

	virtual UpdatesObserver::Uptr RegisterObserver (UpdatesObserver::Uptr
observer=nullptr) noexcept=0;

	virtual ara::core::Result<void> RollbackTransaction (TransactionId id)
noexcept=0;

	virtual ara::core::Result<void> UnsubscribeObserver (KeySlot &slot)
noexcept=0;

	KeyStorageProvider& operator= (const KeyStorageProvider
&other)=default;

	KeyStorageProvider& operator= (KeyStorageProvider &&other)=default;

	
};
---------------------------------------------------
#include "ara/crypto/keys/updates_observer.h"
namespace ara::crypto::keys
class UpdatesObserver 
{
public:
	using Uptr = std::unique_ptr<UpdatesObserver>;

	virtual ~UpdatesObserver () noexcept=default;
	
	virtual void OnUpdate (const TransactionScope &updatedSlots)
noexcept=0;

	UpdatesObserver& operator= (const UpdatesObserver &other)=default;
	
	UpdatesObserver& operator= (UpdatesObserver &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/keys/key_slot_content_props.h"
namespace ara::crypto::keys

constexpr bool operator== (const KeySlotContentProps &lhs, const Key
SlotContentProps &rhs) noexcept;

constexpr bool operator!= (const KeySlotContentProps &lhs, const Key
SlotContentProps &rhs) noexcept;

struct KeySlotContentProps
{
	using Uptr = std::unique_ptr<KeySlotContentProps>;

	KeySlotContentProps ()=default;
	
	CryptoAlgId mAlgId;
	
	std::size_t mObjectSize;
	
	CryptoObjectType mObjectType;
	
	CryptoObjectUid mObjectUid;
	
	AllowedUsageFlags mContentAllowedUsage;
}
---------------------------------------------------
#include "ara/crypto/keys/key_slot_prototype_props.h"
namespace ara::crypto::keys

constexpr bool operator== (const KeySlotPrototypeProps &lhs, const Key
SlotPrototypeProps &rhs) noexcept;

constexpr bool operator!= (const KeySlotPrototypeProps &lhs, const Key
SlotPrototypeProps &rhs) noexcept;

struct KeySlotPrototypeProps
{
	using Uptr = std::unique_ptr<KeySlotPrototypeProps>;
	
	KeySlotPrototypeProps ()=default;
	
	CryptoAlgId mAlgId;
	
	bool mAllocateSpareSlot;
	
	bool mAllowContentTypeChange;
	
	AllowedUsageFlags mContentAllowedUsage;
	
	bool mExportAllowed;
	
	std::int32_t mMaxUpdateAllowed;
	
	KeySlotType mSlotType;
	
	std::size_t mSlotCapacity;
	
	CryptoObjectType mObjectType;
}
---------------------------------------------------
#include "ara/crypto/keys/elementary_types.h"
namespace ara::crypto::keys
using TransactionId = std::uint64_t;
using TransactionScope = ara::core::Vector<KeySlot>;
---------------------------------------------------
#include "ara/crypto/common/base_id_types.h"
namespace ara::crypto
using AllowedUsageFlags = std::uint32_t;
using ByteVector = ara::core::Vector<std::uint8_t, Alloc>;
using CryptoAlgId = std::uint64_t;
enum class CryptoObjectType : std::uint32_t 
{
	kUndefined= 0,
	kSymmetricKey= 1,
	kPrivateKey= 2,
	kPublicKey= 3,
	kSignature= 4,
	kSecretSeed= 5
};

enum class ProviderType : std::uint32_t 
{
	kUndefinedProvider= 0,
	kCryptoProvider= 1,
	kKeyStorageProvider= 2,
	kX509Provider= 3
};

enum class CryptoTransform : std::uint32_t 
{
	kEncrypt= 1,
	kDecrypt= 2,
	kMacVerify= 3,
	kMacGenerate= 4,
	kWrap= 5,
	kUnwrap= 6,
	kSigVerify= 7,
	kSigGenerate= 8
};

enum class KeySlotType : std::uint32_t
{
	kMachine= 1,
	kApplication= 2
};
---------------------------------------------------
#include "ara/crypto/common/mem_region.h"
namespace ara::crypto
using ReadOnlyMemRegion = ara::core::Span<const std::uint8_t>;
using ReadWriteMemRegion = ara::core::Span<std::uint8_t>;
--------------------------------------------------
#include "ara/crypto/common/crypto_error_domain.h
namespace ara::crypto
enum class CryptoErrc : ara::core::ErrorDomain::CodeType {...};
----------------------------------------------------
#include "ara/crypto/common/entry_point.h"
namespace ara::crypto
struct SecureCounter {...};
----------------------------------------------------
#include "ara/crypto/common/serializable.h"
namespace ara::crypto
class Serializable
{
public:
	using FormatId = std::uint32_t;
}
----------------------------------------------------
#include "ara/crypto/common/volatile_trusted_container.h"
namespace ara::crypto
class VolatileTrustedContainer
{
public:
	using Uptr = std::unique_ptr<VolatileTrustedContainer>;
}
----------------------------------------------------
#include "ara/crypto/common/uuid.h
namespace ara::crypto
struct Uuid {...};
----------------------------------------------------
#include "ara/crypto/common/io_interface.h"
namespace ara::crypto
class IOInterface
{
public:
	using Uptr = std::unique_ptr<IOInterface>;
	
	using Uptrc = std::unique_ptr<const IOInterface>;
}
---------------------------------------------------
#include "ara/crypto/common/crypto_error_domain.h"
namespace ara::crypto
class CryptoErrorDomain
{
public:
	using Errc = CryptoErrc;
	using Exception = CryptoException;
}

class CryptoException
{
public:
	explicit CryptoException (ara::core::ErrorCode err) noexcept;
}
---------------------------------------------------





--------------
we ignore
--------------
8.3 C++ language binding X509 Certificate Management Provider





8.5 API Reference      page 316
