---------------------------------------------------
#include "ara/crypto/common/base_id_types.h"
namespace ara::crypto
using AllowedUsageFlags = std::uint32_t;
using ByteVector = ara::core::Vector<std::uint8_t, Alloc>;
using CryptoAlgId = std::uint64_t;
enum class CryptoObjectType : std::uint32_t 
{
	kUndefined= 0,
	kSymmetricKey= 1,
	kPrivateKey= 2,
	kPublicKey= 3,
	kSignature= 4,
	kSecretSeed= 5
};

enum class ProviderType : std::uint32_t 
{
	kUndefinedProvider= 0,
	kCryptoProvider= 1,
	kKeyStorageProvider= 2,
	kX509Provider= 3
};

enum class CryptoTransform : std::uint32_t 
{
	kEncrypt= 1,
	kDecrypt= 2,
	kMacVerify= 3,
	kMacGenerate= 4,
	kWrap= 5,
	kUnwrap= 6,
	kSigVerify= 7,
	kSigGenerate= 8
};

enum class KeySlotType : std::uint32_t
{
	kMachine= 1,
	kApplication= 2
};

const CryptoAlgId kAlgIdUndefined = 0u;
const CryptoAlgId kAlgIdAny = kAlgIdUndefined;
const CryptoAlgId kAlgIdDefault = kAlgIdUndefined;
const CryptoAlgId kAlgIdNone = kAlgIdUndefined;

const AllowedUsageFlags kAllowPrototypedOnly = 0;
const AllowedUsageFlags kAllowDataEncryption = 0x0001;
const AllowedUsageFlags kAllowDataDecryption = 0x0002;
const AllowedUsageFlags kAllowExactModeOnly = 0x8000;
const AllowedUsageFlags kAllowKdfMaterial = 0x0080;
const AllowedUsageFlags kAllowKeyAgreement = 0x0010;
const AllowedUsageFlags kAllowKeyDiversify = 0x0020;
const AllowedUsageFlags kAllowKeyExporting = 0x0100;
const AllowedUsageFlags kAllowKeyImporting = 0x0200;
const AllowedUsageFlags kAllowRngInit = 0x0040;
const AllowedUsageFlags kAllowSignature = 0x0004;
const AllowedUsageFlags kAllowVerification = 0x0008;
const AllowedUsageFlags kAllowDerivedDataDecryption = kAllowDataDecryption << 16;
const AllowedUsageFlags kAllowDerivedDataEncryption = kAllowDataEncryption << 16;
const AllowedUsageFlags kAllowDerivedRngInit = kAllowRngInit << 16;
const AllowedUsageFlags kAllowDerivedExactModeOnly = kAllowExactModeOnly << 16;
const AllowedUsageFlags kAllowDerivedKdfMaterial = kAllowKdfMaterial << 16;
const AllowedUsageFlags kAllowDerivedKeyDiversify = kAllowKeyDiversify << 16;
const AllowedUsageFlags kAllowDerivedKeyExporting = kAllowKeyExporting << 16;
const AllowedUsageFlags kAllowDerivedKeyImporting = kAllowKeyImporting << 16;
const AllowedUsageFlags kAllowDerivedSignature = kAllowSignature << 16;
const AllowedUsageFlags kAllowDerivedVerification = kAllowVerification << 16;

const AllowedUsageFlags kAllowKdfMaterialAnyUsage = kAllowKdfMaterial | kAllowDerivedDataEncryption 
																	  | kAllowDerivedDataDecryption 
																	  | kAllowDerivedSignature 
																	  | kAllowDerivedVerification 
																	  | kAllowDerivedKeyDiversify 
																	  | kAllowDerivedRngInit 
																	  | kAllowDerivedKdfMaterial 
																	  | kAllowDerivedKeyExporting 
																	  | kAllowDerivedKeyImporting;
---------------------------------------------------
#include "ara/crypto/common/mem_region.h"
namespace ara::crypto
using ReadOnlyMemRegion = ara::core::Span<const std::uint8_t>;
using ReadWriteMemRegion = ara::core::Span<std::uint8_t>;
---------------------------------------------------
#include "ara/crypto/common/uuid.h"
namespace ara::crypto

constexpr bool operator== (const Uuid &lhs, const Uuid &rhs) noexcept;

constexpr bool operator< (const Uuid &lhs, const Uuid &rhs) noexcept;

constexpr bool operator> (const Uuid &lhs, const Uuid &rhs) noexcept;

constexpr bool operator!= (const Uuid &lhs, const Uuid &rhs) noexcept; 

constexpr bool operator<= (const Uuid &lhs, const Uuid &rhs) noexcept;

constexpr bool operator>= (const Uuid &lhs, const Uuid &rhs) noexcept;

struct Uuid
{
	std::uint64_t mQwordLs = 0u;
	std::uint64_t mQwordMs = 0u;
	
	bool IsNil () const noexcept;
};
---------------------------------------------------
#include "ara/crypto/common/crypto_object_uid.h"
namespace ara::crypto
struct CryptoObjectUid
{
	Uuid mGeneratorUid;
	std::uint64_t mVersionStamp = 0u;
	
	
	constexpr bool HasEarlierVersionThan (const CryptoObjectUid &anotherId) const noexcept;

	constexpr bool HasLaterVersionThan (const CryptoObjectUid &anotherId) const noexcept;

	constexpr bool HasSameSourceAs (const CryptoObjectUid &anotherId) const noexcept;

	bool IsNil () const noexcept;
	
	bool SourceIsNil () const noexcept;
}

constexpr bool operator== (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;

constexpr bool operator< (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;

constexpr bool operator> (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;

constexpr bool operator!= (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;

constexpr bool operator<= (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;

constexpr bool operator>= (const CryptoObjectUid &lhs, const CryptoObjectUid &rhs) noexcept;
----------------------------------------------------
#include "ara/crypto/cryp/cryobj/crypto_primitive_id.h
namespace ara::crypto::cryp
class CryptoPrimitiveId 
{
public:
	using Uptrc = std::unique_ptr<const CryptoPrimitiveId>;
	using Uptr = std::unique_ptr<CryptoPrimitiveId>;
	using AlgId = CryptoAlgId;


	
	virtual AlgId GetPrimitiveId () const noexcept=0;
	
	virtual const ara::core::StringView GetPrimitiveName () const noexcept=0;



	CryptoPrimitiveId& operator= (const CryptoPrimitiveId &other)=default;

	CryptoPrimitiveId& operator= (CryptoPrimitiveId &&other)=default;
		
	virtual ~CryptoPrimitiveId () noexcept=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/extension_service.h"
namespace ara::crypto::cryp
class ExtensionService 
{
public:
	using Uptr = std::unique_ptr<ExtensionService>;
	
	
	
	virtual std::size_t GetActualKeyBitLength () const noexcept=0;

	virtual CryptoObjectUid GetActualKeyCOUID () const noexcept=0;

	virtual AllowedUsageFlags GetAllowedUsage () const noexcept=0;
	
	virtual std::size_t GetMaxKeyBitLength () const noexcept=0;

	virtual std::size_t GetMinKeyBitLength () const noexcept=0;

	virtual bool IsKeyBitLengthSupported (std::size_t keyBitLength) const noexcept=0;

	virtual bool IsKeyAvailable () const noexcept=0;
	
	
	
	ExtensionService& operator= (const ExtensionService &other)=default;

	ExtensionService& operator= (ExtensionService &&other)=default;
	
	virtual ~ExtensionService () noexcept=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_service.h"
namespace ara::crypto::cryp
class CryptoService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<CryptoService>;
	
	
	
	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const noexcept=0;
	
	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false) const noexcept=0;
};
----------------------------------------------------
#include "ara/crypto/cryp/signature_service.h"
namespace ara::crypto::cryp
class SignatureService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<SignatureService>;
	
	
	
	virtual CryptoPrimitiveId::AlgId GetRequiredHashAlgId () const noexcept=0;

	virtual std::size_t GetRequiredHashSize () const noexcept=0;

	virtual std::size_t GetSignatureSize () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/block_service.h"
namespace ara::crypto::cryp
class BlockService : public ExtensionService 
{
public:
	using Uptr = std::unique_ptr<BlockService>;
	
	
	
	virtual std::size_t GetActualIvBitLength (ara::core::Optional< CryptoObjectUid > ivUid) const noexcept=0;

	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetIvSize () const noexcept=0;
	
	virtual bool IsValidIvSize (std::size_t ivSize) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/digest_service.h"
namespace ara::crypto::cryp
class DigestService : public BlockService 
{
public:
	using Uptr = std::unique_ptr<DigestService>;
	
	virtual ara::core::Result<bool> Compare ( ReadOnlyMemRegion expected, 
											  std::size_t offset=0
											) const noexcept=0;

	virtual std::size_t GetDigestSize () const noexcept=0;
	
	virtual bool IsFinished () const noexcept=0;
	
	virtual bool IsStarted () const noexcept=0;
};
-----------------------------------------------------------
#include "ara/crypto/cryp/cryobj/crypto_object.h
namespace ara::crypto::cryp
class CryptoObject 
{
public:
	struct COIdentifier 
	{
	   CryptoObjectType mCOType;
	   CryptoObjectUid mCouid;
	};
	using Uptrc = std::unique_ptr<const CryptoObject>;
	using Uptr = std::unique_ptr<CryptoObject>
	
	
	template <class ConcreteObject>
	static ara::core::Result<typename ConcreteObject::Uptrc> Downcast (CryptoObject::Uptrc &&object) noexcept;

	virtual CryptoPrimitiveId::Uptr GetCryptoPrimitiveId () const noexcept=0;

	virtual COIdentifier GetObjectId () const noexcept=0;
	
	virtual std::size_t GetPayloadSize () const noexcept=0;
	
	virtual COIdentifier HasDependence () const noexcept=0;
	
	virtual bool IsExportable () const noexcept=0;
	
	virtual bool IsSession () const noexcept=0;
	
	virtual ara::core::Result<void> Save (IOInterface &container) const noexcept=0;



	CryptoObject& operator= (const CryptoObject &other)=default;

	CryptoObject& operator= (CryptoObject &&other)=default;
	
	virtual ~CryptoObject () noexcept=default;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/signature.h"
namespace ara::crypto::cryp
class Signature : public CryptoObject
{
public:
	using Uptrc = std::unique_ptr<const Signature>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kSignature;

	virtual CryptoPrimitiveId::AlgId GetHashAlgId () const noexcept=0;
	
	virtual std::size_t GetRequiredHashSize () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/restricted_use_object.h"
namespace ara::crypto::cryp
class RestrictedUseObject : public CryptoObject {
{
public:
	using Uptrc = std::unique_ptr<const RestrictedUseObject>;
	using Usage = AllowedUsageFlags;
	
	virtual Usage GetAllowedUsage () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/symmetric_key.h"
namespace ara::crypto::cryp
class SymmetricKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const SymmetricKey>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kSymmetricKey;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/private_key.h"
namespace ara::crypto::cryp
class PrivateKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const PrivateKey>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kPrivateKey;
	
	virtual ara::core::Result<PublicKey::Uptrc> GetPublicKey () const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/public_key.h"
namespace ara::crypto::cryp
class PublicKey : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const PublicKey>;

	static const CryptoObjectType kObjectType = CryptoObjectType::kPublicKey;
	
	virtual bool CheckKey(bool strongCheck=true) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > HashPublicKey (HashFunctionCtx &hashFunc) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/cryobj/secret_seed.h"
namespace ara::crypto::cryp
class SecretSeed : public RestrictedUseObject
{
public:
	using Uptrc = std::unique_ptr<const SecretSeed>;
	using Uptr = std::unique_ptr<SecretSeed>;
	
	static const CryptoObjectType kObjectType = CryptoObjectType::kSecretSeed;


	virtual ara::core::Result<SecretSeed::Uptr> Clone (ReadOnlyMemRegionxorDelta=ReadOnlyMemRegion()) const noexcept=0;

	virtual ara::core::Result<void> JumpFrom (const SecretSeed &from, std::int64_t steps) noexcept=0;

	virtual SecretSeed& Jump (std::int64_t steps) noexcept=0;
	
	virtual SecretSeed& Next () noexcept=0;
	
	virtual SecretSeed& operatorˆ= (const SecretSeed &source) noexcept=0;

	virtual SecretSeed& operatorˆ= (ReadOnlyMemRegion source) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_context.h"
namespace ara::crypto::cryp
class CryptoContext 
{
public:
	using AlgId = CryptoAlgId;
	
	virtual CryptoProvider& MyProvider () const noexcept=0;

	virtual CryptoPrimitiveId::Uptr GetCryptoPrimitiveId () const noexcept=0;

	virtual bool IsInitialized () const noexcept=0;
	
	
	
	CryptoContext& operator= (const CryptoContext &other)=default;

	CryptoContext& operator= (CryptoContext &&other)=default;
	
	virtual ~CryptoContext () noexcept=default;
};

-----------------------contexts--------------------
SymmetricBlockCipher
SymmetricKeyWrapper
EncryptorPublic
DecryptorPrivate
HashFunction
KeyAgreementPrivate
KeyDecapsulatorPrivate
KeyDerivationFunction
KeyEncapsulatorPublic
MessageAuthnCode
MsgRecoveryPublic
AuthCipher
SigEncodePrivate
RandomGenerator
StreamCipher
VerifierPublic
SignerPrivate
---------------------------------------------------
#include "ara/crypto/cryp/symmetric_block_cipher_ctx.h
namespace ara::crypto::cryp
class SymmetricBlockCipherCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<SymmetricBlockCipherCtx>;
	
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;
	
	virtual ara::core::Result<CryptoTransform> GetTransformation () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBlock ( ReadOnlyMemRegion in,
																				  bool suppressPadding=false
																				) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBlocks (ReadOnlyMemRegion in) const noexcept=0;

	
	virtual ara::core::Result<void> SetKey ( const SymmetricKey &key,
                           	                 CryptoTransform transform=CryptoTransform::kEncrypt
										   ) noexcept=0;
										   
	virtual ara::core::Result<void> Reset () noexcept=0;
};
---------------------------------------------------










#include "ara/crypto/cryp/symmetric_key_wrapper_ctx.h"
namespace ara::crypto::cryp
class SymmetricKeyWrapperCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<SymmetricKeyWrapperCtx>;
	
	virtual std::size_t CalculateWrappedKeySize (std::size_t keyLength)
const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetMaxTargetKeyLength () const noexcept=0;
	
	virtual std::size_t GetTargetKeyGranularity () const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey ( const SymmetricKey &key,
											 CryptoTransform transform
										   ) noexcept=0;

	template <typename ExpectedKey>
	ara::core::Result<typename ExpectedKey::Uptrc> UnwrapConcreteKey ( ReadOnlyMemRegion wrappedKey,
																	   AlgId algId,
																       AllowedUsageFlags allowedUsage
																     ) noexcept;

	virtual ara::core::Result<RestrictedUseObject::Uptrc> UnwrapKey ( ReadOnlyMemRegion wrappedKey,
																	  AlgId algId, 
																	  AllowedUsageFlags allowedUsage
																	) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> UnwrapSeed ( ReadOnlyMemRegion wrappedSeed, 
															  AlgId targetAlgId, 
															  SecretSeed::Usage allowedUsage
															) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > WrapKeyMaterial (const RestrictedUseObject &key) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/encryptor_public_ctx.h
namespace ara::crypto::cryp
class EncryptorPublicCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<EncryptorPublicCtx>;
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBlock ( ReadOnlyMemRegion in,
																				  bool suppressPadding=false
																				) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/hash_function_ctx.h"
namespace ara::crypto::cryp
class HashFunctionCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<HashFunctionCtx>;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Finish () noexcept=0;

	virtual DigestService::Uptr GetDigestService () const noexcept=0;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > GetDigest (std::size_t offset=0) const noexcept=0;

	virtual ara::core::Result<void> Start () noexcept=0;
	
	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv) noexcept=0;

	virtual ara::core::Result<void> Update (const RestrictedUseObject &in) noexcept=0;

	virtual ara::core::Result<void> Update (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> Update (std::uint8_t in) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_agreement_private_ctx.h"
namespace ara::crypto::cryp
class KeyAgreementPrivateCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyAgreementPrivateCtx>;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> AgreeKey ( const PublicKey &otherSideKey,
															  CryptoAlgId targetAlgId,
															  AllowedUsageFlags allowedUsage,
															  ara::core::Optional< const KeyDerivationFunctionCtx::Uptr > kdf,
															  ara::core::Optional< ReadOnlyMemRegion > salt,
															  ara::core::Optional< ReadOnlyMemRegion > ctxLabel
															) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> AgreeSeed ( const PublicKey &otherSideKey,
															 ara::core::Optional< AllowedUsageFlags > allowedUsage
														   ) const noexcept=0;

	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_decapsulator_private_ctx.h"
namespace ara::crypto::cryp
class KeyDecapsulatorPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<KeyDecapsulatorPrivateCtx>;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> DecapsulateKey ( ReadOnlyMemRegion input,
																	CryptoAlgId keyingDataAlgId,
																	KeyDerivationFunctionCtx &kdf,
																	CryptoAlgId kekAlgId,
																	ara::core::Optional< AllowedUsageFlags > allowedUsage
																  ) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> DecapsulateSeed ( ReadOnly
																   MemRegion input,
																   ara::core::Optional< AllowedUsageFlags > allowed
																   Usage
																  ) const noexcept=0;

	virtual std::size_t GetEncapsulatedSize () const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetKekEntropy () const noexcept=0;
	
	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_derivation_function_ctx.h"
namespace ara::crypto::cryp
class KeyDerivationFunctionCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyDerivationFunctionCtx>;
	
	virtual ara::core::Result<void> AddSalt (ReadOnlyMemRegion salt) noexcept=0;

	virtual ara::core::Result<void> AddSecretSalt (const SecretSeed &salt) noexcept=0;

	virtual std::uint32_t ConfigIterations (std::uint32_t iterations=0) noexcept=0;

	virtual ara::core::Result<SymmetricKey::Uptrc> DeriveKey ( bool isSession=true,
															   bool isExportable=false
															 ) const noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> DeriveSeed ( bool isSession=true, 
															  bool isExportable=false
															) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetKeyIdSize () const noexcept=0;

	virtual AlgId GetTargetAlgId () const noexcept=0;
	
	virtual AllowedUsageFlags GetTargetAllowedUsage () const noexcept=0;

	virtual std::size_t GetTargetKeyBitLength () const noexcept=0;

	virtual ara::core::Result<void> Init ( ReadOnlyMemRegion targetKeyId,
										   AlgId targetAlgId=kAlgIdAny,
										   AllowedUsageFlags allowedUsage=kAllowKdf
										   MaterialAnyUsage,
										   ReadOnlyMemRegion ctxLabel=ReadOnlyMemRegion()
										 ) noexcept=0;
	
	virtual ara::core::Result<void> SetSourceKeyMaterial (const RestrictedUseObject &sourceKM) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/key_encapsulator_public_ctx.h
namespace ara::crypto::cryp
class KeyEncapsulatorPublicCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<KeyEncapsulatorPublicCtx>;
	
	virtual std::size_t GetEncapsulatedSize () const noexcept=0;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetKekEntropy () const noexcept=0;
	
	virtual ara::core::Result<void> AddKeyingData (const RestrictedUseObject &keyingData) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Encapsulate ( KeyDerivationFunctionCtx &kdf,
																				 CryptoAlgId kekAlgId
																			   ) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key) noexcept=0;
}
---------------------------------------------------
#include "ara/crypto/cryp/message_authn_code_ctx.h"
namespace ara::crypto::cryp
class MessageAuthnCodeCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<MessageAuthnCodeCtx>;
	
	virtual ara::core::Result<bool> Check (const Signature &expected) const noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> Finish (bool makeSignature Object=false) noexcept=0;

	virtual DigestService::Uptr GetDigestService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > GetDigest (std::size_t offset=0) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey ( const SymmetricKey &key, 
	                                         CryptoTransform transform=CryptoTransform::kMacGenerate) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnlyMemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv) noexcept=0;

	virtual ara::core::Result<void> Update (const RestrictedUseObject &in) noexcept=0;

	virtual ara::core::Result<void> Update (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> Update (std::uint8_t in) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/msg_recovery_public_ctx.h
namespace ara::crypto::cryp
class MsgRecoveryPublicCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<MsgRecoveryPublicCtx>;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const noexcept=0;
	
	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > DecodeAndVerify (ReadOnlyMemRegion in) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;

	virtual ara::core::Result<void> SetKey (const PublicKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/auth_cipher_ctx.h"
namespace ara::crypto::cryp
class AuthCipherCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<AuthCipherCtx>;

	
	virtual ara::core::Result<bool> Check (const Signature &expected) const noexcept=0;

	virtual DigestService::Uptr GetDigestService () const noexcept=0;
	
	virtual ara::core::Result<CryptoTransform> GetTransformation () const noexcept=0;

	virtual std::uint64_t GetMaxAssociatedDataSize () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessConfidentialData ( ReadOnlyMemRegion in,
																							 ara::core::Optional< ReadOnlyMemRegion > expectedTag
																						   ) noexcept=0;

	virtual ara::core::Result<void> ProcessConfidentialData ( ReadWriteMemRegion inOut, 
															  ara::core::Optional< ReadOnlyMemRegion > expectedTag
															) noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey ( const SymmetricKey &key,
											 CryptoTransform transform=CryptoTransform::kEncrypt
										   ) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnlyMemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv) noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (const RestrictedUseObject &in) noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> UpdateAssociatedData (std::uint8_t in) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/decryptor_private_ctx.h"
namespace ara::crypto::cryp
class DecryptorPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<DecryptorPrivateCtx>;
	
	virtual CryptoService::Uptr GetCryptoService () const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBlock ( ReadOnlyMemRegion in, 
	                                                                              bool suppressPadding=false
																				) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/sig_encode_private_ctx.h"
namespace ara::crypto::cryp
class SigEncodePrivateCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<SigEncodePrivateCtx>;
	
	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const noexcept=0;

	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > SignAndEncode (ReadOnlyMemRegion in) const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/random_generator_ctx.h"
namespace ara::crypto::cryp
class RandomGeneratorCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<RandomGeneratorCtx>;
	
	virtual bool AddEntropy (ReadOnlyMemRegion entropy) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Generate (std::uint32_t count) noexcept=0;

	virtual ExtensionService::Uptr GetExtensionService () const noexcept=0;

	virtual bool Seed (ReadOnlyMemRegion seed) noexcept=0;
	
	virtual bool Seed (const SecretSeed &seed) noexcept=0;
	
	virtual bool SetKey (const SymmetricKey &key) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/signer_private_ctx.h"
namespace ara::crypto::cryp
class SignerPrivateCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<SignerPrivateCtx>;
	
	virtual SignatureService::Uptr GetSignatureService () const noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PrivateKey &key) noexcept=0;
	
	virtual ara::core::Result<Signature::Uptrc> SignPreHashed ( const HashFunctionCtx &hashFn,
																ReadOnlyMemRegion context=ReadOnlyMemRegion()
															  ) const noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > Sign( ReadOnlyMemRegion value,
																		 ReadOnlyMemRegion context=ReadOnlyMemRegion()
																	   ) const noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> SignPreHashed ( AlgId hashAlgId,
																ReadOnlyMemRegion hashValue,
																ReadOnlyMemRegion context=ReadOnlyMemRegion()
															  ) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/stream_cipher_ctx.h
namespace ara::crypto::cryp
class StreamCipherCtx : public CryptoContext
{
public:
	using Uptr = std::unique_ptr<StreamCipherCtx>;
	
	virtual std::size_t CountBytesInCache () const noexcept=0;
	
	std::size_t EstimateMaxInputSize (std::size_t outputCapacity) const noexcept;

	std::size_t EstimateRequiredCapacity (std::size_t inputSize, bool isFinal=false) const noexcept;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > FinishBytes (ReadOnlyMemRegion in) noexcept=0;

	virtual BlockService::Uptr GetBlockService () const noexcept=0;

	virtual bool IsBytewiseMode () const noexcept=0;
	
	virtual ara::core::Result<CryptoTransform> GetTransformation () const noexcept=0;
	
	virtual bool IsSeekableMode () const noexcept=0;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBlocks (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> ProcessBlocks (ReadWriteMemRegion inOut) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ProcessBytes (ReadOnlyMemRegion in) noexcept=0;

	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> Seek (std::int64_t offset, bool fromBegin=true) noexcept=0;

	virtual ara::core::Result<void> SetKey (const SymmetricKey &key, CryptoTransform transform=CryptoTransform::kEncrypt) noexcept=0;

	virtual ara::core::Result<void> Start (ReadOnlyMemRegion iv=ReadOnlyMemRegion()) noexcept=0;

	virtual ara::core::Result<void> Start (const SecretSeed &iv) noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/verifier_public_ctx.h"
namespace ara::crypto::cryp
class VerifierPublicCtx : public CryptoContext 
{
public:
	using Uptr = std::unique_ptr<VerifierPublicCtx>;
	
	virtual SignatureService::Uptr GetSignatureService () const noexcept=0;
	
	virtual ara::core::Result<void> Reset () noexcept=0;
	
	virtual ara::core::Result<void> SetKey (const PublicKey &key) noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed ( CryptoAlgId hashAlgId, 
													  ReadOnlyMemRegion hashValue, 
													  const Signature &signature, 
													  ReadOnlyMemRegion context=ReadOnlyMemRegion()
													) const noexcept=0;

	virtual ara::core::Result<bool> Verify ( ReadOnlyMemRegion value,
											 ReadOnlyMemRegion signature, 
											 ReadOnlyMemRegion context=ReadOnlyMemRegion()
										   ) const noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed ( const HashFunctionCtx &hashFn, 
													  const Signature &signature, 
													  ReadOnlyMemRegion context=ReadOnlyMemRegion()
													) const noexcept=0;

	virtual ara::core::Result<bool> VerifyPrehashed (const HashFunctionCtx
&hashFn, ReadOnlyMemRegion signature, ReadOnlyMemRegion context=Read
OnlyMemRegion()) const noexcept=0;
};
---------------------------------------------------
#include "ara/crypto/cryp/crypto_provider.h"
namespace ara::crypto::cryp
class CryptoProvider 
{
public:
	using AlgId = CryptoPrimitiveId::AlgId;
	using Uptr = std::unique_ptr<CryptoProvider>;
	
	virtual ara::core::Result<VolatileTrustedContainer::Uptr> Alloc
VolatileContainer (std::size_t capacity=0) noexcept=0;

	virtual ara::core::Result<VolatileTrustedContainer::Uptr> Alloc
VolatileContainer (std::pair< AlgId, CryptoObjectType > theObjectDef)
noexcept=0;

	virtual AlgId ConvertToAlgId (ara::core::StringView primitiveName)
const noexcept=0;

	virtual ara::core::Result<ara::core::String> ConvertToAlgName (AlgId algId) const noexcept=0;

	virtual ara::core::Result<AuthCipherCtx::Uptr> CreateAuthCipherCtx ( AlgId algId) noexcept=0;
	
	virtual ara::core::Result<DecryptorPrivateCtx::Uptr> CreateDecryptorPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<EncryptorPublicCtx::Uptr> CreateEncryptorPublicCtx (AlgId algId) noexcept=0;


	virtual ara::core::Result<Signature::Uptrc> CreateHashDigest (AlgId hashAlgId, ReadOnlyMemRegion value) noexcept=0;

	virtual ara::core::Result<HashFunctionCtx::Uptr> CreateHashFunctionCtx(AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyAgreementPrivateCtx::Uptr> CreateKeyAgreementPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyDecapsulatorPrivateCtx::Uptr> CreateKeyDecapsulatorPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyDerivationFunctionCtx::Uptr> CreateKeyDerivationFunctionCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<KeyEncapsulatorPublicCtx::Uptr> CreateKeyEncapsulatorPublicCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<MessageAuthnCodeCtx::Uptr> CreateMessageAuthCodeCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<MsgRecoveryPublicCtx::Uptr> CreateMsgRecoveryPublicCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<RandomGeneratorCtx::Uptr> CreateRandomGeneratorCtx ( AlgId algId=kAlgIdDefault,
																				   bool initialize=true
																				 )noexcept=0;

	virtual ara::core::Result<SigEncodePrivateCtx::Uptr> CreateSigEncodePrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<Signature::Uptrc> CreateSignature ( AlgId signAlgId,
																  ReadOnlyMemRegion value,
																  const RestrictedUseObject &key,
																  AlgId hashAlgId=kAlgIdNone
																) noexcept=0;

	virtual ara::core::Result<SignerPrivateCtx::Uptr> CreateSignerPrivateCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<StreamCipherCtx::Uptr> CreateStreamCipherCtx(AlgId algId) noexcept=0;

	virtual ara::core::Result<SymmetricBlockCipherCtx::Uptr> CreateSymmetricBlockCipherCtx (AlgId algId) noexcept=0;

	virtual ara::core::Result<SymmetricKeyWrapperCtx::Uptr> CreateSymmetricKeyWrapperCtx (AlgId algId) noexcept=0;
	
	virtual ara::core::Result<VerifierPublicCtx::Uptr> CreateVerifierPublicCtx (AlgId algId) noexcept=0;

	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ExportPublicObject ( const IOInterface &container,
																						Serializable::FormatIdformatId=Serializable::kFormatDefault
																					  ) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ExportSecuredObject ( const CryptoObject &object, 
																						 SymmetricKeyWrapperCtx &transportContext
																					   ) noexcept=0;

	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ExportSecuredObject ( const IOInterface &container,
																						 SymmetricKeyWrapperCtx &transportContext
																					   ) noexcept=0;

	virtual ara::core::Result<PrivateKey::Uptrc> GeneratePrivateKey ( AlgId algId, 
																	  AllowedUsageFlags allowedUsage, 
																	  bool isSession=false, 
																	  bool isExportable=false
																	) noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> GenerateSeed ( AlgId algId,
																SecretSeed::Usage allowedUsage,
																bool isSession=true,
																bool isExportable=false
															  ) noexcept=0;
	
	virtual ara::core::Result<SymmetricKey::Uptrc> GenerateSymmetricKey ( AlgId algId, 
																		  AllowedUsageFlags allowedUsage,
																		  bool isSession=true,
																		  bool isExportable=false
																		) noexcept=0;

	virtual ara::core::Result<std::size_t> GetPayloadStorageSize ( CryptoObjectType cryptoObjectType,
																   AlgId algId
																 ) const noexcept=0;

	virtual ara::core::Result<std::size_t> GetSerializedSize ( CryptoObjectType cryptoObjectType,
															   AlgId algId,
															   Serializable::FormatId formatId=Serializable::kFormatDefault
															 ) const noexcept=0;

	virtual ara::core::Result<void> ImportPublicObject ( IOInterface &container,
														 ReadOnlyMemRegion serialized,
														 CryptoObjectType expectedObject=CryptoObjectType::kUndefined
													   ) noexcept=0;

	virtual ara::core::Result<void> ImportSecuredObject ( IOInterface &container,
														  ReadOnlyMemRegion serialized,
														  SymmetricKeyWrapperCtx &transportContext,
														  bool isExportable=false,
														  CryptoObjectType expectedObject=CryptoObjectType::kUndefined
														) noexcept=0;

	virtual ara::core::Result<CryptoObject::Uptrc> LoadObject (const IOInterface &container) noexcept=0;

	virtual ara::core::Result<PrivateKey::Uptrc> LoadPrivateKey (const IOInterface &container) noexcept=0;

	virtual ara::core::Result<PublicKey::Uptrc> LoadPublicKey (const IOInterface &container) noexcept=0;

	virtual ara::core::Result<SecretSeed::Uptrc> LoadSecretSeed (const IOInterface &container) noexcept=0;

	virtual ara::core::Result<SymmetricKey::Uptrc> LoadSymmetricKey (const IOInterface &container) noexcept=0;

	
	virtual std::size_t GetBlockSize () const noexcept=0;
	
	virtual std::size_t GetMaxInputSize (bool suppressPadding=false) const noexcept=0;

	virtual std::size_t GetMaxOutputSize (bool suppressPadding=false) const noexcept=0;


	CryptoProvider& operator= (const CryptoProvider &other)=default;
	
	CryptoProvider& operator= (CryptoProvider &&other)=default;
	
	virtual ~CryptoProvider () noexcept=default;
};
---------------------------------------------------
#include "ara/crypto/keys/keyslot.h"
namespace ara::crypto::keys
class KeySlot
{
public:
	virtual ara::core::Result<void> Clear () noexcept=0;
	
	virtual ~KeySlot () noexcept=default;
	
	virtual ara::core::Result<KeySlotContentProps> GetContentProps () const noexcept=0;

	virtual ara::core::Result<cryp::CryptoProvider::Uptr> MyProvider () const noexcept=0;

	virtual ara::core::Result<KeySlotPrototypeProps> GetPrototypedProps () const noexcept=0;

	virtual bool IsEmpty () const noexcept=0;
	
	virtual ara::core::Result<IOInterface::Uptr> Open (bool subscribeForUpdates=false, bool writeable=false) const noexcept=0;

	virtual ara::core::Result<void> SaveCopy (const IOInterface &container) noexcept=0;

	KeySlot& operator= (const KeySlot &other)=default;
	
	KeySlot& operator= (KeySlot &&other)=default;
	
	using Uptr = std::unique_ptr<KeySlot>;
};
---------------------------------------------------
#include "ara/crypto/keys/key_storage_provider.h"
namespace ara::crypto::keys
class KeyStorageProvider
{
public:
	using Uptr = std::unique_ptr<KeyStorageProvider>;

	virtual ara::core::Result<TransactionId> BeginTransaction (const TransactionScope &targetSlots) noexcept=0;

	virtual ara::core::Result<void> CommitTransaction (TransactionId id) noexcept=0;

	virtual ~KeyStorageProvider () noexcept=default;
	
	virtual UpdatesObserver::Uptr GetRegisteredObserver () const noexcept=0;

	virtual ara::core::Result<KeySlot::Uptr> LoadKeySlot (ara::core::InstanceSpecifier &iSpecify) noexcept=0;

	virtual UpdatesObserver::Uptr RegisterObserver (UpdatesObserver::Uptr observer=nullptr) noexcept=0;

	virtual ara::core::Result<void> RollbackTransaction (TransactionId id) noexcept=0;

	virtual ara::core::Result<void> UnsubscribeObserver (KeySlot &slot) noexcept=0;

	KeyStorageProvider& operator= (const KeyStorageProvider &other)=default;

	KeyStorageProvider& operator= (KeyStorageProvider &&other)=default;	
};
---------------------------------------------------
#include "ara/crypto/keys/updates_observer.h"
namespace ara::crypto::keys
class UpdatesObserver 
{
public:
	using Uptr = std::unique_ptr<UpdatesObserver>;

	virtual ~UpdatesObserver () noexcept=default;
	
	virtual void OnUpdate (const TransactionScope &updatedSlots) noexcept=0;

	UpdatesObserver& operator= (const UpdatesObserver &other)=default;
	
	UpdatesObserver& operator= (UpdatesObserver &&other)=default;
};
---------------------------------------------------
#include "ara/crypto/keys/key_slot_content_props.h"
namespace ara::crypto::keys

constexpr bool operator== (const KeySlotContentProps &lhs, const KeySlotContentProps &rhs) noexcept;

constexpr bool operator!= (const KeySlotContentProps &lhs, const KeySlotContentProps &rhs) noexcept;

struct KeySlotContentProps
{
	using Uptr = std::unique_ptr<KeySlotContentProps>;

	KeySlotContentProps ()=default;
	
	CryptoAlgId mAlgId;
	
	std::size_t mObjectSize;
	
	CryptoObjectType mObjectType;
	
	CryptoObjectUid mObjectUid;
	
	AllowedUsageFlags mContentAllowedUsage;
}
---------------------------------------------------
#include "ara/crypto/keys/key_slot_prototype_props.h"
namespace ara::crypto::keys

constexpr bool operator== (const KeySlotPrototypeProps &lhs, const KeySlotPrototypeProps &rhs) noexcept;

constexpr bool operator!= (const KeySlotPrototypeProps &lhs, const KeySlotPrototypeProps &rhs) noexcept;

struct KeySlotPrototypeProps
{
	using Uptr = std::unique_ptr<KeySlotPrototypeProps>;
	
	KeySlotPrototypeProps ()=default;
	
	CryptoAlgId mAlgId;
	
	bool mAllocateSpareSlot;
	
	bool mAllowContentTypeChange;
	
	AllowedUsageFlags mContentAllowedUsage;
	
	bool mExportAllowed;
	
	std::int32_t mMaxUpdateAllowed;
	
	KeySlotType mSlotType;
	
	std::size_t mSlotCapacity;
	
	CryptoObjectType mObjectType;
}
---------------------------------------------------
#include "ara/crypto/keys/elementary_types.h"
namespace ara::crypto::keys
using TransactionId = std::uint64_t;
using TransactionScope = ara::core::Vector<KeySlot>;
--------------------------------------------------
#include "ara/crypto/common/crypto_error_domain.h
namespace ara::crypto
enum class CryptoErrc : ara::core::ErrorDomain::CodeType 

constexpr ara::core::ErrorCode MakeErrorCode (CryptoErrorDomain::Errc
code, ara::core::ErrorDomain::SupportDataType data) noexcept;

----------------------------------------------------
#include "ara/crypto/common/entry_point.h"
namespace ara::crypto
struct SecureCounter 
{
	std::uint64_t mLSQW;
	std::uint64_t mMSQW;
};

cryp::CryptoProvider::Uptr LoadCryptoProvider (const
ara::core::InstanceSpecifier &iSpecify) noexcept;

keys::KeyStorageProvider::Uptr LoadKeyStorageProvider () noexcept;

x509::X509Provider::Uptr LoadX509Provider () noexcept;

ara::core::Result<ara::core::Vector<ara::core::Byte> > GenerateRandom
Data (std::uint32_t count) noexcept;

ara::core::Result<SecureCounter> GetSecureCounter () noexcept;
----------------------------------------------------
#include "ara/crypto/common/serializable.h"
namespace ara::crypto
class Serializable
{
public:
	using FormatId = std::uint32_t;
	static const FormatId kFormatDefault = 0;
	static const FormatId kFormatRawValueOnly = 1;
	static const FormatId kFormatDerEncoded = 2;
	static const FormatId kFormatPemEncoded = 3;
	
	virtual ~Serializable () noexcept=default;
	
	virtual ara::core::Result<ara::core::Vector<ara::core::Byte> > ExportPublicly (FormatId formatId=kFormatDefault) const noexcept=0;

	Serializable& operator= (const Serializable &other)=default;
	
	Serializable& operator= (Serializable &&other)=default;
}
----------------------------------------------------
#include "ara/crypto/common/io_interface.h"
namespace ara::crypto
class IOInterface
{
public:
	using Uptr = std::unique_ptr<IOInterface>;
	using Uptrc = std::unique_ptr<const IOInterface>;
	
	
	virtual AllowedUsageFlags GetAllowedUsage () const noexcept=0;
	
	virtual std::size_t GetCapacity () const noexcept=0;
	
	virtual CryptoObjectType GetCryptoObjectType () const noexcept=0;
	
	virtual CryptoObjectUid GetObjectId () const noexcept=0;
	
	virtual std::size_t GetPayloadSize () const noexcept=0;
	
	virtual CryptoAlgId GetPrimitiveId () const noexcept=0;
	
	virtual CryptoObjectType GetTypeRestriction () const noexcept=0;
	
	virtual bool IsObjectExportable () const noexcept=0;
	
	virtual bool IsObjectSession () const noexcept=0;
	
	virtual bool IsVolatile () const noexcept=0;
	
	virtual bool IsValid () const noexcept=0;
	
	virtual bool IsWritable () const noexcept=0;
	
	
	
	IOInterface& operator= (const IOInterface &other)=default;
	
	IOInterface& operator= (IOInterface &&other)=default;
	
	virtual ~IOInterface () noexcept=default;
};
----------------------------------------------------
#include "ara/crypto/common/volatile_trusted_container.h"
namespace ara::crypto
class VolatileTrustedContainer
{
public:
	using Uptr = std::unique_ptr<VolatileTrustedContainer>;
	
	virtual IOInterface& GetIOInterface () const noexcept=0;
	
	
	
	VolatileTrustedContainer& operator= (const VolatileTrustedContainer &other)=default;

	VolatileTrustedContainer& operator= (VolatileTrustedContainer &&other)=default;
	
	virtual ~VolatileTrustedContainer () noexcept=default;
}
---------------------------------------------------
#include "ara/crypto/common/crypto_error_domain.h"
namespace ara::crypto
class CryptoErrorDomain
{
public:
	using Errc = CryptoErrc;
	using Exception = CryptoException;
	
	void ThrowAsException (const ara::core::ErrorCode &errorCode) const
override;

	constexpr CryptoErrorDomain () noexcept;
	
	const char* Name () const noexcept override;
	
	const char* Message (ara::core::ErrorDomain::CodeType errorCode) const
noexcept override;
}

class CryptoException
{
public:
	explicit CryptoException (ara::core::ErrorCode err) noexcept;
}
---------------------------------------------------





--------------
we ignore
--------------
8.3 C++ language binding X509 Certificate Management Provider
A Mentioned Manifest Elements
B Interfaces to other Functional Clusters (informative)
